# JUnit
**JUnit** - Java-библиотека для тестирования отдельных модулей (Unit'ов) ПО
## Rules
> JUnit поддерживает удобный механизм правил (Rules). Они позволяют влиять на поведение всех тестов в классе. 
> Правило представляет собой код, исполняющийся "вокруг" тестового метода, для каждого такого метода, позволяя расширить и переделывать поведение JUnit каким удобно образом.
> Простейшими правилами, вшитыми в JUnit являются `@Before`, `@BeforeClass` и `@After`, `@AfterClass`.
- **`@Before`** - метод, помеченный данной аннотацией, будет вызван перед выполнением каждого теста.
- **`@BeforeClass`** - статический метод с этой аннотацией выполнится один раз перед началом выполнения всех тестов в классе.
- **`@Test`** - метод, помеченный этой аннотацией, является тестом
  * Аннотация может принимать два параметра:
    *expected* - класс исключения, которое должен выбросить тест для успешного завершения. Если исключение не выброшено или выброшено другое, то тест завершился неудачно.
    *timeout* - максимальное время в миллисекундах, за которое должен выполниться тест.
- **`@After`** - метод, помеченный этой аннотацией, выполнится после каждого теста. Гарантируется, что он выполнится, даже если метод с ``@Before`` или ``@Test`` выбросит исключение.
- **`@AfterClass`** - метод, c этой аннотацией, выполнится после прохождения всех тестов в классе. Гарантируется выполнение, даже если будет выброшено исключение.

### Custom Rules
Для повторного использования кода существует возможность создать собственный набор правил. Для этого необходимо реализовать метод `apply()` интерфейса `org.junit.rules.TestRule`. Метод `apply()` должен возвращать объект типа `org.junit.runners.model.Statement`. Вызов правила, в свою очередь, представляет собой вызов метода `evaluate()` объекта `Statement`. Следовательно, для написания собственного правила надо обернуть вызов `evaluate()` своим кодом. Например:
```java
public class MyNewRule implements TestRule {

    @Override
    public Statement apply(final Statement base, Description description) {
        return new Statement() {
            @Override
            public void evaluate() throws Throwable {
                System.out.println("before");
                base.evaluate();
                System.out.println("after");
            }
        };
    }
}
```

# Mockito
- **Mockito** - Популярный фреймворк для Mock-тестирования
- **Mock** - Аннотация из Mockito для создания заглушки (будь то класса или интерфейса)

# Spring
- **SpringBootTest** - Аннотация, используемая для выполнения интеграционного тестирования (противоположность Unit-тестов). При тестировании запускает всё приложение. В свойстве *webEnvironment* можно указать, какой окружение будет использоваться при запуске, например:
  * *WebEnvironment.MOCK* - грузит ``EmbeddedWebApplicationContext``, но использует Mock'овое сервлет-окружение. Установлено по дефолту. Часто используется совместно с ``@AutoConfigureMockMvc`` для тестирования с использованием MockMvc. Если в *classpath* нет никакого Servlet API, то подгрузится ``ApplicationContext`` и веб-окружение использоваться не будет.
  * *WebEnvironment.RANDOM_PORT* - подгрузится ``EmbeddedWebApplicationContext`` и запустятся реальные сервлет-контейнеры (*Embedded servlet containers*), которые будут слушать случайный порт (веб окружение используется).
  * *WebEnvironment.DEFINED_PORT* - аналогично предыдущему, за исключением того, что приложение будет слушать либо порт, указанный в application.properties, либо дефолтный 8080.
  * *WebEnvironment.NONE* - загрузится ``ApplicationContext``, не будет использоваться веб-окружение (*webEnvironment*).
- **MockMvc** - Спринговый класс, который может имитировать Http-запросы контроллеру (вместе с хедерами, куки, телом запроса и т.д.) и анализировать результаты этого запроса (e.g., статус и тело ответа)
- **TestRestTemplate** - класс, с помощью которого можно отправлять реальные http-запросы к нашему серверу. Необходимо указание либо *WebEnvironment.RANDOM_PORT*, либо *WebEnvironment.DEFINED_PORT*.

- **MockBean** - аннотация для создания Mock-а из spring-boot. Если Bean типа, помеченного этой аннотацией, уже определён в ``ApplicationContext``, то он будет заменён Mock'ом (заглушкой). Если Bean такого типа не определен в контексте, то будет добавлен новый (как Mock).
- **SpyBean** - также "спрингбутовая" аннотация. Отличие от ``@MockBean`` заключается в том, что она позволяет не заместить Mock'ом класс, а обернуть оберткой и заместить или проверить вызов отдельных его методов. ``ApplicationContext`` при этом не перезаписывается
